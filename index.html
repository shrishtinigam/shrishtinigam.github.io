<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Performance, Projects, Perspective">
  <title>shrishtinigam.github.io</title>
  <link rel="stylesheet" href="https://shrishtinigam.github.io/static/css/style.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap" rel="stylesheet">
  <script>
    function toggleMenu() {
      const nav = document.getElementById('mobile-nav');
      nav.classList.toggle('open');
    }
  </script>
</head>

<body>
  <header class="site-header">
    <div class="container header-container">
      <a href="https://shrishtinigam.github.io" class="brand">shrishtinigam.github.io</a>
      <nav class="site-nav desktop-nav">
        <a href="https://shrishtinigam.github.io">Home</a>
        <a href="https://shrishtinigam.github.io/about">About</a>
        <a href="https://shrishtinigam.github.io/projects">Projects</a>
        <a href="https://shrishtinigam.github.io/posts">Posts</a>
      </nav>
      <button class="hamburger" onclick="toggleMenu()">☰</button>
    </div>
    <nav id="mobile-nav" class="site-nav mobile-nav">
      <a href="https://shrishtinigam.github.io" onclick="toggleMenu()">Home</a>
      <a href="https://shrishtinigam.github.io/about" onclick="toggleMenu()">About</a>
      <a href="https://shrishtinigam.github.io/projects" onclick="toggleMenu()">Projects</a>
      <a href="https://shrishtinigam.github.io/posts" onclick="toggleMenu()">Posts</a>
    </nav>
  </header>

  <main>
    

<!-- Hero Section -->
<section class="hero container">
  <h1 class="section-heading">Hello, I'm Meher Shrishti Nigam.</h1>
  <p class="hero-description">Performance, Projects, Perspective</p>
</section>

<!-- About Section -->
<section id="about" class="container about">
  <h2 class="section-heading">About Me</h2>
  <div class="about-text">
    <p>I’m Meher, a software developer at BlackRock in the Risk and Quantitative Analysis Department – Core Risk Engineering (CRE) Team.</p><br><p>At CRE, I build Python-based low-code pipelines that orchestrate data end-to-end.</p><br><p>I extract from databases, messaging systems, RPC, FTP, and REST APIs, transform with Python and R in Dockerized environments, and deliver actionable insights via PowerBI and Python visualizations for Risk Managers.</p><br><p>I focus on high-performance solutions and clean, maintainable software design.</p><br><p>I hold a degree in Computer Science and Engineering, with a specialization in Large Language Models.</p><br><p>When I am not working, I’m curating playlists (120 and counting).</p>
  </div>
</section>

<!-- Projects Section -->
<section id="projects" class="container projects">
  <h2 class="section-heading">Projects</h2>
  <div class="project-list">
    
    
    <article class="project-card">
      <h3>
        <a
          href="https://shrishtinigam.github.io/projects/microservices-based-web-app/index.html">
          Microservices Based E-Commerce Web App
        </a>
      </h3>
      
      <p class="muted"><strong>University Project</strong> - <em>May 2023 - Jun 2023</em></p>
      
      <p class="muted"><em>Node.js · JavaScript · React.js · TypeScript · Docker · Kubernetes</em></p>
      <p>Scalable microservices E-Commerce app with Node.js, TypeScript, React, and Kubernetes; orders managed via Redis and Bull.js.</p>
      <a class="read-more" href="https://shrishtinigam.github.io/projects/microservices-based-web-app/index.html">
        View Details →
      </a>
    </article>
    
    <article class="project-card">
      <h3>
        <a
          href="https://shrishtinigam.github.io/projects/pathfinding-algorithms-visualizer/index.html">
          Pathfinding Algorithms Visualizers (SFML)
        </a>
      </h3>
      
      <p class="muted"><strong>University Project</strong> - <em>May 2023 - Jun 2023</em></p>
      
      <p class="muted"><em>Object-Oriented Programming (OOP) · C++ · SFML</em></p>
      <p>Visualized and optimized four pathfinding algorithms on a grid map using C++ and SFML, highlighting performance metrics and efficient A* implementation.</p>
      <a class="read-more" href="https://shrishtinigam.github.io/projects/pathfinding-algorithms-visualizer/index.html">
        View Details →
      </a>
    </article>
    
    <article class="project-card">
      <h3>
        <a
          href="https://shrishtinigam.github.io/projects/dyslexic-char-recognition/index.html">
          Dyslexic Character Recognition
        </a>
      </h3>
      
      <p class="muted"><strong>University Project</strong> - <em>Sep 2022 - Nov 2022</em></p>
      
      <p class="muted"><em>Convolutional Neural Networks (CNN) · TensorFlow · Python</em></p>
      <p>CNN-based system to recognize handwritten characters for dyslexia, achieving 90% accuracy.</p>
      <a class="read-more" href="https://shrishtinigam.github.io/projects/dyslexic-char-recognition/index.html">
        View Details →
      </a>
    </article>
    
    <article class="project-card">
      <h3>
        <a
          href="https://shrishtinigam.github.io/projects/chronic-kidney-disease-pred/index.html">
          Chronic Kidney Disease Prediction
        </a>
      </h3>
      
      <p class="muted"><strong>University Project</strong> - <em>Apr 2022 - Jul 2022</em></p>
      
      <p class="muted"><em>scikit · TensorFlow · Seaborn · pandas · Python</em></p>
      <p>Performed predictive modeling for Chronic Kidney Disease using multiple ML models and CNN on the UCI CKD dataset.</p>
      <a class="read-more" href="https://shrishtinigam.github.io/projects/chronic-kidney-disease-pred/index.html">
        View Details →
      </a>
    </article>
    
    <article class="project-card">
      <h3>
        <a
          href="https://shrishtinigam.github.io/projects/mner-xlm-roberta/index.html">
          Multilingual Named Entity Recognition using XLM-RoBERTa
        </a>
      </h3>
      
      <p class="muted"><strong>University Project</strong> - <em>May 2022 - Jul 2022</em></p>
      
      <p class="muted"><em>Large Language Models (LLM) · Transformer Models · Named Entity Recognition (NER) · NLP · Python</em></p>
      <p>Fine-tuned XLM-RoBERTa for multilingual Named Entity Recognition on Indian languages, achieving effective cross-lingual performance.</p>
      <a class="read-more" href="https://shrishtinigam.github.io/projects/mner-xlm-roberta/index.html">
        View Details →
      </a>
    </article>
    
    
  </div>
</section>

<!-- Latest Posts Section -->
<section id="posts" class="container posts">
  <h2 class="section-heading">Latest Blog Posts</h2>
  <div class="post-list">
    
    
    <article class="post-card">
      <h3>
        <a
          href="https://shrishtinigam.github.io/posts/semantic-versioning-p2/index.html">
          Get 𝖲̶𝖾̶𝗆̶𝖺̶𝗇̶𝗍̶𝗂̶𝖼̶ Versioning Right in Your Python Library - Part 2
        </a>
      </h3>
      <p class="muted">Sep 21, 2025</p>
      <p><p>Now that we have a basic understanding of software versioning principles and the Python interpreter/standard libraries, we can get on with how Python libraries are versioned.</p>
<h2 id="right-what-about-python-libraries">Right, What About Python Libraries?</h2>
<p>Great question, we are getting there.</p>
<p>Third-party Python libraries aren’t controlled by the core Python team, so authors are technically free to choose their own versioning schemes. That said, PyPI package versions must be <a href="https://peps.python.org/pep-0440/">PEP 440</a> compliant. Most popular libraries follow this PEP, which puts down the official Python versioning standards for Python libraries and packages.</p>
<p><strong>PEP 440</strong> states that the version identifiers must comply with this scheme:</p>
<div style="text-align: center;">
<b>[N!]N(.N)*[{a|b|rc}N][.postN][.devN] </b>
</div>
<p><br></p>
<p>Public version identifiers are separated into up to <a href="https://packaging.python.org/en/latest/specifications/version-specifiers/">five segments</a>:</p>
<ol>
<li>
<p><strong>Epoch segment: N!</strong></p>
<ul>
<li>This is used very rarely, and its primary purpose is to reset the version numbering. I won't go into detail about this.</li>
</ul>
</li>
<li>
<p><strong>Release segment: N(.N)</strong></p>
<ul>
<li>The main version numbers, usually in <code>major.minor.micro</code> format. Eg: <code>2.1.3</code></li>
<li>Sometimes <code>major.minor</code> is also used.</li>
</ul>
</li>
<li>
<p><strong>Pre-release segment: {a|b|rc}N</strong></p>
<ul>
<li>Marks alpha, beta, or release candidate versions.</li>
<li>Excluded by default unless explicitly requested.</li>
<li>Examples:<ul>
<li>1.0a1 → first alpha of version 1.0</li>
<li>2.0b2 → second beta of version 2.0</li>
<li>3.1rc1 → first release candidate of 3.1</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Post-release segment: .postN</strong></p>
<ul>
<li>Marks minor fixes after a release.</li>
<li>Example: 1.0.post1 → first post-release of version 1.0</li>
</ul>
</li>
<li>
<p><strong>Development release segment: .devN</strong></p>
<ul>
<li>Marks ongoing development versions that are not yet stable.</li>
<li>Example: 1.0.dev1 → first development build of version 1.0</li>
<li>Example: 2.0.0.dev5 → fifth development build of version 2.0.0</li>
</ul>
</li>
</ol>
<p>PEP 440 also allows date-based versions, which can be handy for automated builds.</p>
<ul>
<li>Example: 2025.09 → September 2025 release</li>
<li>Example: 2025.09.14 → September 14, 2025 release</li>
</ul>
<p>While the scheme allows many segments, most libraries use two or three components:</p>
<ul>
<li>Major.Minor: 1.2 → Major release 1, minor update 2</li>
<li>Major.Minor.Micro: 1.2.3 → Major 1, minor 2, micro 3 (typical for bug fixes)</li>
</ul>
<p><strong>Stable releases</strong> omit pre-release, post-release, and development suffixes:</p>
<div style="text-align: center;">
<b>N(.N)*</b>
</div>

<h4 id="example-order-ladder">Example Order Ladder</h4>
<p>PEP 440 defines Python version ordering so tools like pip know which is newer:</p>
<pre class="codehilite"><code class="language-bash">1.2.dev1 &lt; 1.2a1 &lt; 1.2b1 &lt; 1.2rc1 &lt; 1.2 &lt; 1.2.post1
</code></pre>

<ul>
<li>devN: early dev release</li>
<li>aN / bN / rcN: alpha, beta, release candidate</li>
<li>final: stable release</li>
<li>.postN: post-release hotfix or docs</li>
<li>+local versions are ignored in comparisons</li>
</ul>
<hr>
<h2 id="my-job-its-just-pip">.. My Job? It's Just <code>pip</code></h2>
<p>When you run the simple command </p>
<pre class="codehilite"><code class="language-bash">pip install numpy
</code></pre>

<p>or</p>
<pre class="codehilite"><code class="language-bash">pip install requirements.txt
</code></pre>

<p>or if you're using <code>pyproject.toml</code></p>
<pre class="codehilite"><code class="language-bash">pip install .
</code></pre>

<p>what’s actually happening behind the scenes is called <a href="https://pip.pypa.io/en/stable/topics/dependency-resolution/">dependency resolution</a>.</p>
<blockquote>
<p>pip is capable of determining and installing the dependencies of packages. The process of determining which version of a dependency to install is known as dependency resolution.</p>
</blockquote>
<p>Most Python packages need other packages to work, which they declare as <code>dependencies</code>. <code>numpy</code> may require <code>mkl</code> to work, <code>pandas</code> requires <code>numpy</code> to work, <code>seaborn</code> required <code>pandas</code> to work and so on, leading to a <code>dependency tree</code>.</p>
<p>When you run <code>pip install .</code>, pip does the following:</p>
<ol>
<li>Selects the requested packages.</li>
<li>Looks up the dependencies of each package.</li>
<li>Repeats the process recursively for dependencies of dependencies.</li>
<li>Tries to find compatible versions of packages.</li>
</ol>
<p>This sounds simple, but it gets complicated quickly.</p>
<p>If <code>pip</code> finds incompatible versions, it <strong>backtracks</strong>, i.e., tries older versions until it finds a combination that works. This is why sometimes <code>pip</code> seems to download multiple versions of the same package. It's just testing versions to find a compatible set. Even after backtracking, pip might not be able to find a version that is compatible which raises a <strong>version conflict</strong>. </p>
<blockquote>
<p>A version conflict happens when two or more Python packages you want to install depend on different versions of the same library, and there is no single version that satisfies all of them. </p>
</blockquote>
<p><code>pip</code> can’t magically install multiple versions of the same package in the same environment, so it raises an error. Suppose you have the following dependencies:
- Package A requires numpy &gt;= 1.25.0
- Package B requires numpy &lt; 1.24.0
In this case, there is no version of numpy that satisfies both. <code>pip</code> throws a <code>ResolutionImpossible</code> error.</p>
<details>

<h4>Why Version Conflicts Happen</h4>
<ul>
  <li>Pinned versions – Some packages explicitly require a very specific version (e.g., numpy==1.23.0), which reduces flexibility.</li>
  <li>Fast-moving libraries – Libraries like pandas, scikit-learn, and tensorflow release updates frequently, sometimes breaking compatibility with older dependencies.</li>
  <li>Transitive dependencies – Packages often depend on other packages (and those have their own dependencies), which can lead to chains of conflicts.</li>
</ul>

<h4>How to Solve Version Conflicts</h4>
<ul>
  <li>Audit your top-level requirements – Remove unnecessary or overly strict version pins.</li>
  <li>Loosen version constraints – Instead of numpy==1.23.0, try numpy>=1.23.0,&lt;2.0.</li>
  <li>Use a virtual environment – Keeps each project isolated.</li>
  <li>Use a lockfile – Tools like pip-tools or poetry can lock exact working versions to avoid conflicts.</li>
  <li>Check the dependency tree – You can inspect dependencies using:
    <pre><code>pip show package_name
pipdeptree
</code></pre>
  </li>
</ul>

<h4>Reducing Backtracking</h4>
<p>Excessive backtracking can make installs slow. You can let pip resolve the dependencies, or you can help pip by:</p>
<ul>
  <li>Constraining versions – Tell pip to only consider versions within a certain range. This narrows the search space and speeds up resolution.</li>
  <li>Loosen overly strict version pins – If you’ve pinned packages too tightly, pip may struggle to find compatible versions. Relaxing bounds lets pip find a working combination more easily.</li>
  <li>Use constraint or lock files – Constraint files let you fix versions for dependencies, including transitive ones, without modifying your main requirements.</li>
  <li>Use the --upgrade flag – Forcing pip to consider the latest versions of installed packages can prevent unnecessary backtracking (to be used with caution, as you would need to ensure your code is compatible with the latest API).</li>
</ul>


</details>

<p>I hope you noticed the irony too. Make the dependencies too loose, and your resolution time increases or worse, a version is resolved that is not right for you code. Make it too tight, and there is a chances your transitive dependencies may throw a version conflict.</p>
<h2 id="how-does-semantic-versioning-come-into-picture">How Does Semantic Versioning Come Into Picture?</h2>
<p><a href="https://semver.org/">SemVer</a> was introduced in 2009 by GitHub co-founder Tom Preston-Werner, and is a widely accepted. </p>
<blockquote>
<p><strong>Important: PEP 440 version numbers and pip installation do not enforce SemVer. Many libraries adopt SemVer rules voluntarily, but you can’t assume it’s guaranteed.</strong></p>
</blockquote>
<p><strong>PEP 440 says nothing about API stability/backwards compatibility.</strong> It only defines how versions are formatted and compared. <code>pip</code> mostly does <strong>numeric comparisions</strong> of version numbers, guided by PEP 440. <code>pip</code> won’t stop you from installing a "breaking" version. <strong>Thus, many projects adopt SemVer rules within PEP 440</strong>. Please note that <strong>some libraries ignore SemVer or have their own scheme</strong>. Thus, you will need to make sure that the backwards compatibility policy defined by the library is reflected in your version constriant. </p>
<pre class="codehilite"><code class="language-bash">pip install &quot;package&gt;=1.0,&lt;2.0&quot;
</code></pre>

<blockquote>
<p>TLDR: When it comes to package versions, SemVer is not enforced and its better to check policies explicitly.</p>
</blockquote>
<details>
<table border="1" cellpadding="10" cellspacing="0" style="border-collapse: collapse; width: 100%;">
  <thead>
    <tr style="background-color: #171716;">
      <th>Aspect</th>
      <th>PEP 440 (Python Packaging Standard)</th>
      <th>Semantic Versioning (SemVer)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Purpose</strong></td>
      <td>Defines how Python packages must be versioned so <code>pip</code> and PyPI can parse, compare, and resolve them consistently.</td>
      <td>Communicates the type of changes (breaking, new features, bugfixes) across versions.</td>
    </tr>
    <tr>
      <td><strong>Basic Format</strong></td>
      <td><code>N(.N)*[{a b rc}N][.postN][.devN][+local]</code><br>Examples: <code>1.2.0</code>, <code>1.2.0a1</code>, <code>1.2.0rc1</code>, <code>1.2.0.post1</code>, <code>1.2.0.dev1</code>, <code>1.2.0+local.abc123</code></td>
      <td><code>MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]</code><br>Examples: <code>1.2.0</code>, <code>1.2.0-alpha.1</code>, <code>1.2.0-rc.1</code>, <code>1.2.0+20130313144700</code></td>
    </tr>
    <tr>
      <td><strong>Version Segments</strong></td>
      <td>Allows multiple segments: <code>1.2.3.4</code> is valid.</td>
      <td>Exactly three segments: <code>MAJOR.MINOR.PATCH</code>.</td>
    </tr>
    <tr>
      <td><strong>Pre-release Labels</strong></td>
      <td><code>aN</code> (alpha), <code>bN</code> (beta), <code>rcN</code> (release candidate).<br>Example: <code>1.0a1</code>, <code>1.0b2</code>, <code>1.0rc3</code></td>
      <td>Dash-separated identifiers: <code>-alpha.N</code>, <code>-beta.N</code>, <code>-rc.N</code>.<br>Example: <code>1.0.0-alpha.1</code>, <code>1.0.0-beta.2</code>, <code>1.0.0-rc.3</code></td>
    </tr>
    <tr>
      <td><strong>Post Releases</strong></td>
      <td>Supported with <code>.postN</code> (for hotfixes, doc-only updates, etc.).<br>Example: <code>1.0.post1</code></td>
      <td>Not part of the spec — usually bump <code>PATCH</code> instead.</td>
    </tr>
    <tr>
      <td><strong>Development Releases</strong></td>
      <td>Explicit <code>.devN</code> suffix for nightly or dev snapshots.<br>Example: <code>1.0.dev2</code></td>
      <td>No direct equivalent. Some ecosystems use <code>-dev</code> informally, but not standardized.</td>
    </tr>
    <tr>
      <td><strong>Local Versions / Build Metadata</strong></td>
      <td><code>+tag</code> for local builds or downstream variants.<br>Example: <code>1.0+local.1</code></td>
      <td><code>+metadata</code> for build information.<br>Example: <code>1.0.0+build.1</code></td>
    </tr>
    <tr>
      <td><strong>Comparison Rules</strong></td>
      <td>Strict, fully defined.<br><strong>Order ladder:</strong> <code>X.Y.devN &lt; X.YaN &lt; X.YbN &lt; X.YrcN &lt; X.Y &lt; X.Y.postN</code></td>
      <td>Defined but simpler.<br><strong>Order ladder:</strong> <code>X.Y.Z-alpha &lt; X.Y.Z-beta &lt; X.Y.Z-rc &lt; X.Y.Z</code><br>Build metadata (<code>+</code>) ignored for ordering.</td>
    </tr>
    <tr>
      <td><strong>Backward Compatibility Signaling</strong></td>
      <td>Not intrinsic — projects may adopt SemVer rules within PEP 440.</td>
      <td>Core principle:<br>- <code>MAJOR</code> = breaking changes<br>- <code>MINOR</code> = new, backward-compatible features<br>- <code>PATCH</code> = bug fixes</td>
    </tr>
    <tr>
      <td><strong>Flexibility</strong></td>
      <td>Very flexible — supports multi-part versions, dev cycles, post releases, local variants.</td>
      <td>Strict — exactly 3 numeric parts + optional pre-release/build metadata.</td>
    </tr>
    <tr>
      <td><strong>Tooling</strong></td>
      <td>Enforced by Python packaging tools (<code>pip</code>, <code>setuptools</code>, PyPI).</td>
      <td>Enforced differently per ecosystem (npm, cargo, Maven, etc.), not Python.</td>
    </tr>
  </tbody>
</table>

</details></p>
      <a class="read-more"
        href="https://shrishtinigam.github.io/posts/semantic-versioning-p2/index.html">
        Read →
      </a>
    </article>
    
    <article class="post-card">
      <h3>
        <a
          href="https://shrishtinigam.github.io/posts/semantic-versioning-p3/index.html">
          Get 𝖲̶𝖾̶𝗆̶𝖺̶𝗇̶𝗍̶𝗂̶𝖼̶ Versioning Right in Your Python Library - Part 3
        </a>
      </h3>
      <p class="muted">Sep 21, 2025</p>
      <p><p>In this final part of getting versioning right in your Python library, I explore practical steps to ensure your library is maintainable, PEP-compliant, and future-proof. I also plan to add more code and practical examples in the future.</p>
<h2 id="how-should-i-version-my-libraries">How Should I Version My Libraries?</h2>
<p>The best practice for Python library versioning under PEP 440 is to adopt a three-part scheme like SemVer. SemVer is widely recognized, easy to understand, and helps standardize which changes are backward-compatible versus breaking. Setting your package’s versioning policy this way makes it clear to users which upgrades are safe.</p>
<p>The following rules are recommended:</p>
<div style="text-align: center;">
  <b>[MAJOR].[MINOR].[PATCH]</b>
</div>
<p><br></p>
<ul>
<li>MAJOR → backward-incompatible changes.</li>
<li>MINOR → backward-compatible features.</li>
<li>PATCH → backward-compatible bug fixes.</li>
</ul>
<h3 id="development-pre-release-versions">Development &amp; Pre-release Versions</h3>
<p>When a library is preparing a new release, there are several intermediate stages before the final stable version. PEP 440 defines how these are labeled.</p>
<h4 id="example-backward-compatible-update">Example: Backward-Compatible Update</h4>
<p>Suppose a library is at 1.2.0 and wants to release backward-compatible new features. 
According to SemVer / PEP 440, this means a minor bump → 1.3.0.</p>
<p>Development &amp; pre-release versions could look like this:</p>
<pre class="codehilite"><code class="language-bash">1.3.0.dev1   # dev snapshot
1.3.0a1      # alpha pre-release
1.3.0b1      # beta pre-release
1.3.0rc1     # release candidate
1.3.0        # final release
</code></pre>

<p>Users can use <code>pip install library==1.3.0</code> to install the latest stable release. Pre-release versions (alpha, beta, release candidates) are ignored by default.
Developers can test pre-releases explicitly with <code>pip install library==1.3.0a1</code> or by using the <code>--pre</code> flag.</p>
<h4 id="example-backward-incompatible-update">Example: Backward-Incompatible Update</h4>
<p>Suppose the library now introduces breaking changes (e.g., removes a function, changes API signature).
According to SemVer / PEP 440, this is a major bump → 2.0.0.
Version progression:</p>
<pre class="codehilite"><code class="language-bash">2.0.0.dev1
2.0.0a1
2.0.0b1
2.0.0rc1
2.0.0
</code></pre>

<p>This signals to users that upgrading may break code relying on 1.x.x.</p>
<h3 id="how-pandas-uses-a-semver-variant">How Pandas uses a SemVer Variant</h3>
<p>I am providing an example of a popular library and its <a href="https://pandas.pydata.org/docs/development/policies.html">versioning policy</a> here to provide some perspective. </p>
<ul>
  <li>Follows a loose SemVer with MAJOR.MINOR.PATCH.</li>
  <li>Major releases: Can introduce breaking API changes, with migration guidance.</li>
  <li>Minor releases: Introduce deprecations that warn users but preserve current behavior.</li>
  <li>Patch releases: Do not add new deprecations; may include bug fixes.</li>
  <li>Deprecated behavior remains until the next major release (e.g., deprecated in 1.2.x, removed in 2.0.0).</li>
  <li>Experimental features: Behavior may change at any time.</li>
  <li>Judgement is used to classify bug fixes vs. API-breaking changes, with community input encouraged.</li>
</ul>

<h3 id="modern-minimum-build-system-requirements-pep-518">Modern Minimum Build System Requirements - PEP 518</h3>
<p><a href="https://peps.python.org/pep-0518/">PEP 518</a> defines a standard way for Python projects to declare their build dependencies in a separate configuration file, rather than relying on setup.py. </p>
<p>Historically, distutils and setuptools used executable setup.py scripts to build distributions. The PEP resolves this by allowing projects to declaratively list the minimal dependencies needed for the build system, so tools like pip can install them upfront. There are more details, which you can read about in PEP 517/518.</p>
<p>The pyproject.toml file is a configuration file standard for Python projects, defined by this PEP. It uses the TOML (Tom's Obvious, Minimal Language) format, which is designed to be human-readable and easy to parse. This is adopted by newer libraries like <code>poetry</code> and <code>flit</code>, that help your create these dependencies. </p>
<p>I will delve into a full Python setup guide in a separate post.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Here’s a quick reference for modern Python library best practices.</p>
<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr>
      <th>Aspect</th>
      <th>Standard Practice</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Versioning</td>
      <td>PEP 440 / non-enforced SemVer</td>
    </tr>
    <tr>
      <td>Dependency declaration</td>
      <td>pyproject.toml (modern), setup.py (older projects)</td>
    </tr>
    <tr>
      <td>Dev dependencies</td>
      <td>optional-dependencies in pyproject.toml or requirements-dev.txt</td>
    </tr>
    <tr>
      <td>Locking dependencies</td>
      <td>Use pip-tools (requirements.txt + requirements.lock) or poetry.lock</td>
    </tr>
    <tr>
      <td>Build / distribution</td>
      <td>python -m build to generate .whl and .tar.gz</td>
    </tr>
  </tbody>
</table>

<p>And there you have it: </p>
<blockquote>
<p>Follow SemVer's Major-Minor-Patch and backwards compatibility rules, </p>
<p>Don't assume everyone else follows them,</p>
<p>Read the versioning scheme policy docs of the libraries you are using, and </p>
<p>Use pyproject.toml.</p>
</blockquote>
<p>Now release that package you've been postponing!</p>
<p><br><br></p>
<h2 id="ps-commit-style">PS: Commit Style</h2>
<p>This part of the article is something I care about deeply personally but mostly unrelated to the rest. When SemVer is applied to commit messages, it helps maintain consistent, meaningful, and easy-to-understand commit histories. Whether you are a "commit everything in one go" or a "small incremental features" person, the core idea behind this style is to categorize commits based on their impact, and help in automated generation of changelogs and releases.</p>
<p>Ultimately, it helps you maintain a clean Git history. This is the format I follow generally, and helps me jump around my commits, as I know what was added or deleted in each commit. I hope this helps you write better commits.</p>
<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr>
      <th>Type</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>feat:</td>
      <td>Adds a new feature</td>
    </tr>
    <tr>
      <td>fix:</td>
      <td>Fixes a bug</td>
    </tr>
    <tr>
      <td>chore:</td>
      <td>Maintenance tasks</td>
    </tr>
    <tr>
      <td>build:</td>
      <td>Build system or dependencies</td>
    </tr>
    <tr>
      <td>docs:</td>
      <td>Documentation updates</td>
    </tr>
    <tr>
      <td>perf:</td>
      <td>Performance improvements</td>
    </tr>
    <tr>
      <td>refactor:</td>
      <td>Code refactoring</td>
    </tr>
    <tr>
      <td>style:</td>
      <td>Code formatting</td>
    </tr>
    <tr>
      <td>test:</td>
      <td>Adding or modifying tests</td>
    </tr>
    <tr>
      <td>ci:</td>
      <td>CI/CD changes</td>
    </tr>
    <tr>
      <td>revert:</td>
      <td>Reverting a commit</td>
    </tr>
    <tr>
      <td>BREAKING CHANGE:</td>
      <td>Major breaking changes</td>
    </tr>
  </tbody>
</table>

<p><br></p>
<details>

I remember being 11-12 years old, sitting at a restaurant with my brother while he was reciting different Andriod versions for me. Each candy-named version evoked a higher pitched laugh, and this remains a fond memory of mine. 

</details></p>
      <a class="read-more"
        href="https://shrishtinigam.github.io/posts/semantic-versioning-p3/index.html">
        Read →
      </a>
    </article>
    
    <article class="post-card">
      <h3>
        <a
          href="https://shrishtinigam.github.io/posts/semantic-versioning-p1/index.html">
          Get 𝖲̶𝖾̶𝗆̶𝖺̶𝗇̶𝗍̶𝗂̶𝖼̶ Versioning Right in Your Python Library - Part 1
        </a>
      </h3>
      <p class="muted">Sep 10, 2025</p>
      <p><p>Understanding versioning and release management of Python is crucial if you maintain Python libraries for a living, as I do. A thorough understanding helps you avoid dependency hell and ensures smooth upgrades during releases. To truly understand how versioning works in Python interpreters and Python libraries, we must begin at the beginning. The first stable version of Python was released in early 1991 (eleven years before I was born) and Python 2.0 was released in the middle of the dot-com crash. Meanwhile, in the wider world of software versioning, Semantic Versioning (SemVer) was introduced in 2009. Python itself didn’t see its latest standardization of versioning until the mid-2010s. In Part 1 of this three-part series, I’ll explore what software versioning is and how Python interpreters are versioned.</p>
<p>Let's unravel this timeline together.</p>
<h2 id="what-is-software-versioning">What is Software Versioning?</h2>
<p>Software versioning can be defined simply -</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Software_versioning">Software versioning</a> is the process of assigning either unique version names or unique version numbers to unique states of computer software.</p>
</blockquote>
<p><br></p>
<blockquote>
<p>A <a href="https://dhtmlx.com/blog/versioning-schemes-importance-web-development/">versioning scheme</a> is a practice of categorizing changes in a software product during its lifecycle. To put it simply, these are unique identifiers containing numbers (or letters) given to different software iterations.</p>
</blockquote>
<p>There is a large variety of version numbering schemes, including but not limited to</p>
<ul>
<li>Semantic Versioning - <code>MAJOR.MINOR.PATCH</code> + strict standard rules</li>
<li>Calendar Versioning - <code>YY.MM</code> like Ubuntu or <code>YYYY.R</code> like Chrome</li>
<li>Marketing Versions - macOS - <code>Tahoe</code>, <code>Sequoia</code>, <code>Sonoma</code> etc, Android <code>Marshmallow</code>, <code>Nougat</code>, <code>Oreo</code></li>
<li>And most commonly, Hybrid Schemes, like <a href="https://openjdk.org/jeps/223">JEP:223 for Java</a>, <a href="https://peps.python.org/pep-0440/">PEP:440 for Python</a></li>
</ul>
<p>.. this list is by no means exhaustive. Some schemes are primarily for developers, some for end-users, and many software projects mix approaches.</p>
<h2 id="okay-so-how-does-python-interpreter-versioning-work">Okay, So How Does Python Interpreter Versioning Work?</h2>
<h3 id="pep-602">PEP 602</h3>
<p><a href="https://peps.python.org/pep-0602/">PEP 602</a> governs Python interpreter <strong>(CPython)</strong> releases starting with Python 3.9. It enforces a predictable annual release cycle, where a new feature version is released in October, once per year. </p>
<p>The development cycle is set to ~17 months per feature version, and each release has a lifecycle of <strong>five</strong> years. This includes <strong>two</strong> years of full support, with bug fixes and security updates, and <strong>three</strong> years of security fixes (source-only releases). This model of versioned and scheduled releases is called a 'software release train'.</p>
<blockquote>
<p>A <a href="https://en.wikipedia.org/wiki/Software_versioning#Release_train">software release train</a> is a form of software release schedule in which a number of distinct series of versioned software releases for multiple products are released as a number of different "trains" on a regular schedule. </p>
</blockquote>
<p>Generally, for each product line, a number of different release trains are running at a given time, with each train moving from initial release to eventual maturity and retirement on a planned schedule.</p>
<p>This standard simply: </p>
<ul>
<li>Makes releases smaller</li>
<li>Puts features and bug fixes in hands of users sooner</li>
<li>Creates a predictable calendar for releases</li>
</ul>
<p>The versioning works like -  </p>
<div style="text-align: center;">
  <b>[major].[minor].[micro][pre-release]</b>
</div>
<p><br></p>
<ol>
<li><strong>Major</strong> → Big changes, only happened from 1 → 2 → 3 (No official Python 4 release is planned as of now)</li>
<li><strong>Minor</strong> → Annual Feature Releases (since PEP 602)</li>
<li><strong>Micro</strong> → Patch/BugFixes, Maintenance releases, typically released ~2 months </li>
<li><strong>Pre-release</strong> → a (alpha), b (beta), rc (release candidate)</li>
</ol>
<p>Of course, dev releases also exist. In short, Python 3.x releases follow a predictable annual schedule, with clear rules for feature and bug fix releases, giving developers a predictable upgrade path. You can explore the incremental additions in recent Python releases.</p>
<h3 id="pep-387">PEP 387</h3>
<p>How backwards compatible are these 'stable' python interpreter releases? How much of my existing code could break with each new Python release, and how should I plan for it - especially since each release is supported for only 5 years? (a brief period of time in terms of enterprise software). Thankfully, PEP 387 defines how Python itself handles backward compatibility in its standard library.</p>
<blockquote>
<p>This <a href="https://peps.python.org/pep-0387/">PEP</a> takes the perspective that “backwards incompatibility” means preexisting code ceases to comparatively function after a change.</p>
</blockquote>
<p>The basic policy applies to all public APIs and dictates the following:</p>
<ol>
<li>No incompatible changes between consecutive releases unless:
    <ul>
        <li>Proper deprecation warnings are provided</li>
        <li>The change has high benefit relative to breakage</li>
    </ul></li>
<li>Deprecation periods typically last at least 2 years, often 5 years for practical purposes.</li>
<li>The Steering Council can grant exceptions for urgent security issues or obsolete features.</li>
</ol>
<p>Note that it does not govern backward compatibility rules for third-party libraries like pandas, numpy, etc.</p>
<p>An example of this deprecation is the <code>collections</code> import style. It was officially deprecated in Python 3.9 and removed later. Warnings are used to slowly warn developers of the changes. This includes <code>PendingDeprecationWarning</code> and <code>DeprecationWarning</code>.</p>
<pre class="codehilite"><code class="language-python"># Old way (deprecated)
from collections import Iterable
# Recommended new way
from collections.abc import Iterable
</code></pre>

<p>If you are planning to deprecate anything in your library, you can use the <code>deprecated</code> decorator from the warning library, as outlined by <a href="http://peps.python.org/pep-0702/">PEP 702</a>.</p>
<pre class="codehilite"><code class="language-python">from warnings import deprecated

@deprecated(&quot;Use Spam instead&quot;)
class Ham: ...
</code></pre></p>
      <a class="read-more"
        href="https://shrishtinigam.github.io/posts/semantic-versioning-p1/index.html">
        Read →
      </a>
    </article>
    
    
  </div>
</section>


  </main>

  <footer class="site-footer">
    <div class="container">
      <p>&copy; Meher Shrishti Nigam — Powered by SSG (Python + Jinja)</p>
    </div>
  </footer>
</body>

</html>